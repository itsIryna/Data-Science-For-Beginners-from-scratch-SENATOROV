"""Measuring performance and analyzing the complexity of algorithms."""

# - чтобы измерить скорость программы используем модули Python timeit и cProfile

# - Они не только изменяют время выполнения кода, но и строят профиль, показывающий,
# какие части кода уже выполняются быстро, а какие можно улучшить.

# - timeit полезен для хронометража небольших фрагментов кода, модуль
# cProfile более эффективен для анализа целых функций или программ

# ```
# import time, cProfile
# def addUpNumbers():
#  total = 0
#  for i in range(1, 1000001):
#  total += i
# cProfile.run('addUpNumbers()')
#
# ```

# Результат выполнения этой программы выглядит примерно так:
#
#  4 function calls in 0.064 seconds
#
#  Ordered by: standard name
#  ncalls tottime percall cumtime percall filename:lineno(function)
#  1 0.000 0.000 0.064 0.064 <string>:1(<module>)
#  1 0.064 0.064 0.064 0.064 test1.py:2(addUpNumbers)

# - ncalls — количество вызовов функции;
# - tottime — общее время, требуемое для выполнения функции, не считая
# времени в подфункциях;
# - percall — общее время, разделенное на количество вызовов;
#  - cumtime — накопленное время для выполнения функции и ее подфункций;
# - percall — общее время, деленное на количество вызовов;
# - filename:lineno(function) — файл, в котором определяется функция, и но-
# мер строки.

# Закон Амдала — формула, которая вычисляет, насколько
# ускорится выполнение программы при улучшении одного из ее фрагментов.
#
# Согласно этой формуле ускорение всей операции равно 1 / ((1 — p) + (p / s)), где
# s — ускорение компонента, а p — доля этого компонента в общем времени вы-
# полнения программы.
#
# Таким образом, если увеличить вдвое скорость фрагмента,
# требующего 90% от общего времени выполнения программы, общее ускорение
# составит 1/((1 – 0,9) + (0,9/2)) = 1,818, или 82%. Это лучше, чем, скажем, утроение
# скорости элемента, который занимает всего 25% от общего времени выполнения;
# в этом случае общее ускорение составит 1 / ((1 – 0,25) + (0,25/2)) = 1,143, или 14%

# ### удвоение скорости самых медленных или длинных частей вашего кода более продуктивно, чем удвоение скорости уже быстрых или коротких частей

# «О-большое» — метод анализа алгоритмов, описывающий масштабирование времени выполнения кода
# - показывает, насколько увеличится
# время выполнения кода при возрастании объема выполняемой работы
#

# ### Порядки нотации «О-большое»
#
# 1. O(1), постоянное время (самый низкий порядок).
# 2. O(log n), логарифмическое время.
# 3. O(n), линейное время.
# 4. O(n log n), время N-Log-N.
# 5. O(n2), полиномиальное время.
# 6. O(2n), экспоненциальное время.
# 7. O(n!), факториальное время (наивысший порядок).

# При увеличении размера books с 10 до 100 алго-
# ритм переходит от значения 1 + 1 + (2 × 10) + 1, или 23 шага, к 1 + 1 + (2 × 100) + 1,
# или 203 шага. Число 203 равно приблизительно 10 × 23, так что время выполнения
# возрастает пропорционально росту n.

# ### Почему низкие порядки и коэффициенты не важны
# Низкие порядки исключаются из подсчета шагов, потому что они становятся менее
# значимыми с увеличением размера n. Если список books из приведенной функции
# readingList() увеличивается с 10 до 10 000 000 000 (10 миллиардов), количество
# шагов увеличится с 23 до 20 000 000 003. При достаточно больших n эти три дополнительных шага ни на что не влияют.

# ### порядки некоторых распространенных операций Python для типов последовательностей — таких как строки, кортежи и списки:
#
# - s[i] reading и s[i] = value assignment — операции O(1).
# - s.append(value) — операция O(1).
# - s.insert(i, value) — операция O(n). Вставка значения в последовательность (особенно в начало) требует сдвига всех элементов индексами выше i на
# одну позицию вверх в последовательности.
# - s.remove(value) — операция O(n). Удаление значений из последовательности
# (особенно в начале) требует сдвига всех элементов с индексами выше i на
# одну позицию вниз в последовательности.
# - s.reverse() — операция O(n), потому что необходимо переставить все эле-
# менты последовательности.
# - s.sort() — операция O(n log n), потому что алгоритм сортировки Python
# имеет сложность O(n log n).
# - value in s — операция O(n), потому что необходимо проверить каждый
# элемент.
# - for value in s: — операция O(n).
# - len(s) — операция O(1), потому что Python хранит количество элементов
# в последовательности, чтобы их не приходилось заново пересчитывать при
# каждом вызове len().

# ### порядки «О-большое» для некоторых распространенных операций Python для типов отображений (таких как словари, множества и фиксированные множества).
# - m[key]reading и m[key] = value assignment — операции O(1).
# - m.add(value) — операция O(1).
# - value in m — операция O(1) для словарей; выполняется намного быстрее, чем для последовательностей.
# - for key in m: — операция O(n).
# - len(m) — операция O(1), потому что Python хранит количество элементов в отображении, чтобы их не приходилось заново пересчитывать при каждом
# вызове len().

# Способ вычисления называется алгоритмом **хеширования**, а адрес — хеш-кодом.

# - Если код не обращается ни к каким данным, это O(1).
# - Если код последовательно перебирает данные, это O(1).
# - Если код содержит два вложенных цикла, каждый из которых перебирает
# данные, это O(n2).
# - Вызовы функций включаются в подсчеты не как один шаг, а как общее количество шагов кода внутри функции.
# - Если код содержит операцию «разделяй и властвуй», которая многократно
# делит данные надвое, это O(log n).
# - Если код содержит операцию «разделяй и властвуй», которая выполняется
# по одному разу для каждого элемента данных, это O(n log n).
# - Если код перебирает все возможные комбинации значений в данных с раз-
# мером n, это O(2n) или другой экспоненциальный порядок.
# - Если код перебирает все возможные перестановки (то есть варианты упоря-
# дочения) значений данных, это O(n!).
# - Если код включает сортировку данных, это как минимум O(n log n).

"""Lists, Tuples and sets."""

# ! pip install nltk

# ## Списки, кортежи и множества

# ### Списки

# Основы работы со списками

# +
# пустой список можно создать через [] или функцию list()
# импортируем класс стеммера и создаем объект
# fmt: off
from nltk.stem import PorterStemmer

# fmt: on

some_list_1: list[int] = []
# pylint: disable=use-list-literal
some_list_2: list[int] = list()

print(some_list_1, some_list_2)
# -

# элементами списка могут быть числа, строки, другие списки и словари
number_three = [3, "число три", ["число", "три"], {"число": 3}]
number_three

# длина списка рассчитывается через функцию len()
len(number_three)

# Индекс и срез списка

# +
# у списка есть положительный и отрицательный индексы
abc_list = ["a", "b", "c", "d", "e"]

# воспользуемся ими для вывода первого и последнего элементов
print(abc_list[0], abc_list[-1])

# +
# при работе с вложенным списком
salary_list = [["Анна", 90000], ["Игорь", 85000], ["Алексей", 95000]]

# мы вначале указываем индекс вложенного списка, а затем индекс элемента в нем
salary_list[1][0]
# -

# индекс можно узнать с помощью метода .index()
abc_list.index("c")

# метод .index() можно применить и ко вложенному списку
salary_list[0].index(90000)

# +
# создадим список с днями недели
days_list = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"]

# и выведем со второго по пятый элемент включительно
days_list[1:5]
# -

# выведем каждый второй элемент в срезе с первого по пятый
days_list[:5:2]

# проверим есть ли "Пн" в списке
"Пн" in days_list

# если "Вт" есть в списке
if "Вт" in days_list:

    # выведем сообщение
    print("Такое слово есть")

# Добавление, замена и удаление элементов списка

# создадим список
weekdays = ["Понедельник", "Вторник"]

# добавим один элемент в конец списка с помощью метода .append()
weekdays.append("Четверг")
weekdays

# добавим элемент в определенное место в списке через желаемый индекс элемента
weekdays.insert(2, "Среда")
weekdays

# изменим четвертый элемент в списке
weekdays[3] = "Пятница"
weekdays

# удалим элемент по его значению
weekdays.remove("Пятница")
weekdays

# удалим элемент по его индексу через ключевое слово del
del weekdays[2]
weekdays

# сделаем то же самое с помощью метода .pop()
# этот метод выводит удаляемый элемент
weekdays.pop(1)

# посмотрим, что осталось в нашем списке
weekdays

# Сложение списков

# +
# соединить два списка можно с помощью метода .extend()
more_weekdays = ["Вторник", "Среда", "Четверг", "Пятница"]

weekdays.extend(more_weekdays)
weekdays

# +
weekend = ["Суббота", "Воскресенье"]

# или просто сложив два списка
print(weekdays + weekend)
# -

# иногда бывает полезно "размножить" элементы списка
["Понедельник"] * 2

# такие "произведения" также можно складывать
["Понедельник"] * 2 + ["Вторник"] * 2

# Распаковка списков

# дан список
week = [
    "Понедельник",
    "Вторник",
    "Среда",
    "Четверг",
    "Пятница",
    "Суббота",
    "Воскресенье",
]

# указав индекс элемента, его можно записать в переменную
Mon = week[0]
Mon

# +
# срез можно поместить в несколько переменных
Mon, Tue, Wed = week[:3]

# важно, чтобы количество элементов среза было равно количеству переменных
Mon, Tue, Wed
# -

# можно выделить первый элемент, а остальные поместить со звездочкой
Mon, *_ = week
Mon

# также можно поступить, например, с первым и последним элементом
Mon, *days, Sun = week
Mon, Sun

# посмотрим, какие элементы остались в переменной со звездочкой
days

# Сортировка списков

# возьмем список чисел
nums = [25, 10, 30, 20, 5, 15]

# и отсортируем с помощью функции sorted(), результат выводится сразу
sorted(nums)

# исходный список при этом не изменился
nums

# если поместить результат в переменную, изменения сохранятся
sorted_nums = sorted(nums)
sorted_nums

# метод .sort() сохраняет результат, но не выводит его сразу
# reverse = True задает сортировку по убыванию
nums.sort(reverse=True)

# выведем результат
nums

# +
# метод .reverse() задает обратный порядок, сохраняет, но не выводит результат
nums.reverse()

# его также нужно вывести отдельно
nums
# -

# функция reversed() возвращает итератор
reversed(nums)

# вывести результат можно с помощью функции list()
list(reversed(nums))

# результат при этом не сохраняется
nums

# Преобразование списка в строку

# дан список из строковых элементов
str_list = ["P", "y", "t", "h", "o", "n"]

# с помощью метода .join() можно соединить все элементы
joined_str = "".join(str_list)
joined_str

# если в кавычках ничего не указывать, элементы просто соединятся
joined_str_ = "_".join(str_list)
joined_str_

# Арифметика в списках

# дан список чисел
nums_ = [3, 2, 1, 4, 5, 12, 3, 3, 7, 9, 11, 15]

# с помощью .count() мы можем посчитать частоту вхождения элемента в список
nums_.count(3)

# кроме того мы можем найти минимальное и максимальное значения и сумму
print(min(nums_), max(nums_), sum(nums_))

# List comprehension

# дан список имен
# оставим имена, начинающиеся с буквы "А"
names = ["Артем", "Антон", "Александр", "Борис", "Виктор", "Геннадий"]

# +
# вначале решим эту задачу с помощью цикла for

# создадим пустой список
a_names = []

# пройдемся по исходному списку в цикле for
for name in names:

    # с помощью метода .startswith() проверим, начинается ли слово с "А"
    if name.startswith("А"):

        # если да, добавим в новый список
        a_names.append(name)

# выведем результат
a_names
# -

# эту же задачу можно решить через list comprehension
a_names = [name for name in names if name.startswith("А")]
a_names

# переведем все буквы в строчные, условие здесь не нужно
lower_names = [name.lower() for name in names]
lower_names

# схема условия if-else немного отличается
# оставляем имя, если это не Виктор, если Виктор - заменяем на Вадим
replace_name = [name if name != "Виктор" else "Вадим" for name in names]
replace_name

# +
# на занятии по обработке естественного языка с помощью list comprehension
# мы применили стеммер Портера к списку слов
lemmatized = [
    "paris",
    "visited",
    "lot",
    "museum",
    "first",
    "went",
    "louvre",
    "largest",
    "art",
    "museum",
    "world",
    "always",
    "interested",
    "art",
    "spent",
    "many",
    "hour",
    "museum",
    "enormous",
    "week",
    "would",
    "enough",
]


porter = PorterStemmer()

# применяем стеммер к элементу s, пока есть элементы s в списке lemmatized
stemmed_p = [porter.stem(string) for string in lemmatized]
print(stemmed_p)
# -

# ### Кортежи

# Основы работы с кортежами

# пустой кортеж можно создать с помощью круглых скобок () или функции tuple()
tuple_1: tuple[int, ...] = ()
tuple_2: tuple[int, ...] = tuple()
print(tuple_1, tuple_2)

# в кортеже элементы упорядочены, а значит есть индекс
letters = ("a", "b", "c")
letters[0]

# +
# но изменить элемент, как мы это делали в списке, нельзя
# letters[0] = 'd'
# -

# для изменения элемента кортеж вначале нужно преобразовать в список
letters_new: list[str] = list(letters)
letters_new[0] = "d"
letters_new

# кортеж из одного элемента можно создать с помощью запятой
let_a = ("a",)
type(let_a)

# Функция enumerate()

# +
companies = ["Microsoft", "Apple", "Tesla"]

# если записать результат функции enumerate() в одну переменную,
for company in enumerate(companies):

    # то мы получим кортежи
    print(company, type(company))
# -

# Просмотр элементов словаря

shopping_dict = {"огурцы": 2, "помидоры": 3, "лук": 1, "картофель": 2}

# то же самое со словарем и методом .items()
for item in shopping_dict.items():
    print(item)

# Распаковка кортежей

# как и список, кортеж можно распаковать в несколько переменных
a_val, b_val, c_val = ("a", "b", "c")
print(a_val)

# +
companies = ["Microsoft", "Apple", "Tesla"]

# распаковку в две переменные с функцией enumerate() мы делать уже умеем
for index_company, company_val in enumerate(companies):
    print(index_company, company_val)

# +
shopping_dict = {"огурцы": 2, "помидоры": 3, "лук": 1, "картофель": 2}

# то же самое с ключами и значениями словаря
for k_val, v_val in shopping_dict.items():
    print(k_val, v_val)
# -

# Функция zip()

# +
# если есть два и более списка
names = ["Артем", "Антон", "Александр", "Борис", "Виктор", "Геннадий"]
income = [97000, 110000, 95000, 84000, 140000, 120000]

# функция zip() соединит первые элементы списков, вторые элементы и т.д.
zip(names, income)
# -

# для вывода результата нужно передать zip-объект в функцию list()
# на выходе мы получим список из кортежей
list(zip(names, income))

# ### Множества

# Создание множества

# +
# пустое множество задается через функцию set()
set_1: set[str] = set()

# непустое множество задается через функцию set() и список элементов
set_2 = {"a", "b", "c"}

# или путем перечисления элементов в фигурных скобках {}
set_3 = {"a", "b", "c"}

# множество содержит только уникальные элементы, поэтому дубликаты удаляются
print(set_1, set_2, set_3)

# +
# создать множество через пустые фигурные скобки нельзя
not_a_set: dict[str, int] = {}

# так создается словарь
type(not_a_set)
# -

# Добавление и удаление элементов

# предположим, что мы хотим создать множество гласных букв в русском языке
vowels = {"а", "о", "э", "е", "у", "ё", "ю"}

# добавим одну букву "я" методом .add()
vowels.add("я")
vowels

# добавим две буквы "и" и "ы" методом .update()
vowels.update(["и", "ы"])
vowels

# если по ошибке мы добавим согласную букву,
vowels.add("щ")
vowels

# ее можно удалить методом .remove()
vowels.remove("щ")
vowels

# Теория множеств в Питоне

# два множества равны, если содержат одинаковые элементы, порядок не важен
{"a", "b", "c"} == {"c", "b", "a"}

# выведем мощность множества с помощью функции len()
len({"a", "b", "c"})

# проверим, содержится ли элемент во множестве
"a" in {"a", "b", "c"}

# возможна и обратная операция
"a" not in {"a", "b", "c"}

# +
# проверим является ли А подмножеством В
set_a = {"a", "b", "c"}
set_b = {"a", "b", "c", "d", "e", "f"}

set_a.issubset(set_b)
# -

# проверим является ли B надмножеством А
set_b.issuperset(set_a)

# даны участники команд по обработке естественного языка (nlp)
# и компьютерному зрению (cv)
nlp = {"Анна", "Николай", "Павел", "Оксана"}
cv = {"Николай", "Евгений", "Ольга", "Оксана"}

# +
# найдем тех, кто работает или в nlp, или в cv, или в обеих командах

# можно использовать метод .union()
print(nlp.union(cv))

# или символ |
print(nlp | cv)
# -

# найдем пересечение множеств, то есть тех, кто работает и в nlp, и в cv
print(nlp.intersection(cv))
print(nlp & cv)

# выведем тех, кто работает только в nlp, но не в cv или cv и nlp одновременно
print(nlp.difference(cv))
print(nlp - cv)

# выведем тех, кто работает только в cv, но не в nlp или nlp и cv одновременно
print(cv.difference(nlp))
print(cv - nlp)

# найдем тех, кто работает или в cv, или в nlp
# но не в обеих областях одновременно
print(nlp.symmetric_difference(cv))
print(nlp ^ cv)